\relax 
\providecommand\hyper@newdestlabel[2]{}
\catcode `"\active 
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\select@language{portuguese}
\@writefile{toc}{\select@language{portuguese}}
\@writefile{lof}{\select@language{portuguese}}
\@writefile{lot}{\select@language{portuguese}}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introdu\IeC {\c c}\IeC {\~a}o}{2}{section.1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Algoritmos Escolhidos}{3}{section.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Base64}{3}{subsection.2.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Rot13}{3}{subsection.2.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Vigenere}{3}{subsection.2.3}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Arquitetura CUDA}{3}{section.3}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Os experimentos}{5}{section.4}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Discuss\IeC {\~a}o dos Resultados}{6}{section.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1}Rot13}{6}{subsection.5.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Tempo de execu\IeC {\c c}\IeC {\~a}o do algoritmo Rot13 sequencial.}}{6}{figure.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Tempo de execu\IeC {\c c}\IeC {\~a}o do algoritmo Rot13 paralelo variando o tamanho de entrada.}}{7}{figure.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Tempo de execu\IeC {\c c}\IeC {\~a}o do algoritmo Rot13 paralelo variando o tamanho do bloco.}}{8}{figure.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Compara\IeC {\c c}\IeC {\~a}o de tempo de execu\IeC {\c c}\IeC {\~a}o do algoritmo Rot13 paralelo e sequencial.}}{9}{figure.4}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Compara\IeC {\c c}\IeC {\~a}o com tempo de execu\IeC {\c c}\IeC {\~a}o com o tempo de leitura da entrada.}}{10}{figure.5}}
\newlabel{fig:read_operation_time}{{5}{10}{Comparação com tempo de execução com o tempo de leitura da entrada}{figure.5}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.2}Vigenere}{10}{subsection.5.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Tempo de execu\IeC {\c c}\IeC {\~a}o do algoritmo Vigenere sequencial.}}{11}{figure.6}}
\newlabel{fig:vigenere_seqtime}{{6}{11}{Tempo de execução do algoritmo Vigenere sequencial}{figure.6}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Tempo de execu\IeC {\c c}\IeC {\~a}o do algoritmo Vigenere paralelo variando o tamanho de entrada. Note que os pontos que marcam abaixo de zero segundos se referem a inst\IeC {\^a}ncias do problema que n\IeC {\~a}o rodaram na GPU por excederem limites como n\IeC {\'u}mero m\IeC {\'a}ximo de blocos.}}{11}{figure.7}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Tempo de execu\IeC {\c c}\IeC {\~a}o do algoritmo Vigenere paralelo variando o tamanho do bloco. Note que os pontos que marcam abaixo de zero se referem a inst\IeC {\^a}ncias do problema que n\IeC {\~a}o rodaram na GPU porque excedem limites como o n\IeC {\'u}mero m\IeC {\'a}ximo de blocos.}}{12}{figure.8}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Compara\IeC {\c c}\IeC {\~a}o de tempo de execu\IeC {\c c}\IeC {\~a}o do algoritmo Vigenere paralelo e sequencial.}}{13}{figure.9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3}Base64}{13}{subsection.5.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Tempo de execu\IeC {\c c}\IeC {\~a}o do algoritmo Base64 sequencial.}}{13}{figure.10}}
\newlabel{fig:vigenere_seqtime}{{10}{13}{Tempo de execução do algoritmo Base64 sequencial}{figure.10}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces Tempo de execu\IeC {\c c}\IeC {\~a}o do algoritmo Base64 paralelo variando o tamanho de entrada. Note que os pontos que marcam abaixo de zero segundos se referem a inst\IeC {\^a}ncias do problema que n\IeC {\~a}o rodaram na GPU por excederem limites como n\IeC {\'u}mero m\IeC {\'a}ximo de blocos.}}{14}{figure.11}}
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces Tempo de execu\IeC {\c c}\IeC {\~a}o do algoritmo Base64 paralelo variando o tamanho do bloco. Note que os pontos que marcam abaixo de zero se referem a inst\IeC {\^a}ncias do problema que n\IeC {\~a}o rodaram na GPU porque excedem limites como o n\IeC {\'u}mero m\IeC {\'a}ximo de blocos.}}{15}{figure.12}}
\@writefile{lof}{\contentsline {figure}{\numberline {13}{\ignorespaces Compara\IeC {\c c}\IeC {\~a}o entre implementa\IeC {\c c}\IeC {\~o}es sequenciais e paralelas de Base64. Apesar do algoritmo sequencial ser mais r\IeC {\'a}pido, \IeC {\'e} poss\IeC {\'\i }vel notar que a vers\IeC {\~a}o paralela escala melhor no tamanho da inst\IeC {\^a}ncia, sugerindo que, para biblias maiores, o overhead de paralelismo seja compensado, tornando a implementa\IeC {\c c}\IeC {\~a}o paralela a mais r\IeC {\'a}pida.}}{16}{figure.13}}
\newlabel{fig:base64_parallelseq}{{13}{16}{Comparação entre implementações sequenciais e paralelas de Base64. Apesar do algoritmo sequencial ser mais rápido, é possível notar que a versão paralela escala melhor no tamanho da instância, sugerindo que, para biblias maiores, o overhead de paralelismo seja compensado, tornando a implementação paralela a mais rápida}{figure.13}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {14}{\ignorespaces Log do programa perf quando rodamos os tr\IeC {\^e}s algoritmos sequenciais implementados. \IeC {\'E} poss\IeC {\'\i }vel ver que o algoritmo Base64 \IeC {\'e} r\IeC {\'a}pido, fazendo com que o paralelismo s\IeC {\'o} seja vantajoso com inst\IeC {\^a}ncias maiores, quando comparamos com Vigenere e Rot13.}}{16}{figure.14}}
\newlabel{fig:base64_seq_perf}{{14}{16}{Log do programa perf quando rodamos os três algoritmos sequenciais implementados. É possível ver que o algoritmo Base64 é rápido, fazendo com que o paralelismo só seja vantajoso com instâncias maiores, quando comparamos com Vigenere e Rot13}{figure.14}{}}
\@writefile{toc}{\contentsline {section}{\numberline {6}Conclus\IeC {\~a}o}{17}{section.6}}
